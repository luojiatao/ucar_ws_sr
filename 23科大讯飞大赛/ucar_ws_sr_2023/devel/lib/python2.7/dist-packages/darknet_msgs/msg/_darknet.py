# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from darknet_msgs/darknet.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class darknet(genpy.Message):
  _md5sum = "96d5d6b2bcac656db2c131f986f9c0bb"
  _type = "darknet_msgs/darknet"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """int8 E_cuv
int8 E_riv
int8 E_whv
int8 E_cov

int8 D_cuv
int8 D_riv
int8 D_whv
int8 D_cov

int8 C_cuv
int8 C_riv
int8 C_whv
int8 C_cov

int8 B_cuv
int8 B_riv
int8 B_whv
int8 B_cov

int8 F_cuf
int8 F_cof
int8 F_waf"""
  __slots__ = ['E_cuv','E_riv','E_whv','E_cov','D_cuv','D_riv','D_whv','D_cov','C_cuv','C_riv','C_whv','C_cov','B_cuv','B_riv','B_whv','B_cov','F_cuf','F_cof','F_waf']
  _slot_types = ['int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8','int8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       E_cuv,E_riv,E_whv,E_cov,D_cuv,D_riv,D_whv,D_cov,C_cuv,C_riv,C_whv,C_cov,B_cuv,B_riv,B_whv,B_cov,F_cuf,F_cof,F_waf

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(darknet, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.E_cuv is None:
        self.E_cuv = 0
      if self.E_riv is None:
        self.E_riv = 0
      if self.E_whv is None:
        self.E_whv = 0
      if self.E_cov is None:
        self.E_cov = 0
      if self.D_cuv is None:
        self.D_cuv = 0
      if self.D_riv is None:
        self.D_riv = 0
      if self.D_whv is None:
        self.D_whv = 0
      if self.D_cov is None:
        self.D_cov = 0
      if self.C_cuv is None:
        self.C_cuv = 0
      if self.C_riv is None:
        self.C_riv = 0
      if self.C_whv is None:
        self.C_whv = 0
      if self.C_cov is None:
        self.C_cov = 0
      if self.B_cuv is None:
        self.B_cuv = 0
      if self.B_riv is None:
        self.B_riv = 0
      if self.B_whv is None:
        self.B_whv = 0
      if self.B_cov is None:
        self.B_cov = 0
      if self.F_cuf is None:
        self.F_cuf = 0
      if self.F_cof is None:
        self.F_cof = 0
      if self.F_waf is None:
        self.F_waf = 0
    else:
      self.E_cuv = 0
      self.E_riv = 0
      self.E_whv = 0
      self.E_cov = 0
      self.D_cuv = 0
      self.D_riv = 0
      self.D_whv = 0
      self.D_cov = 0
      self.C_cuv = 0
      self.C_riv = 0
      self.C_whv = 0
      self.C_cov = 0
      self.B_cuv = 0
      self.B_riv = 0
      self.B_whv = 0
      self.B_cov = 0
      self.F_cuf = 0
      self.F_cof = 0
      self.F_waf = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_19b().pack(_x.E_cuv, _x.E_riv, _x.E_whv, _x.E_cov, _x.D_cuv, _x.D_riv, _x.D_whv, _x.D_cov, _x.C_cuv, _x.C_riv, _x.C_whv, _x.C_cov, _x.B_cuv, _x.B_riv, _x.B_whv, _x.B_cov, _x.F_cuf, _x.F_cof, _x.F_waf))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 19
      (_x.E_cuv, _x.E_riv, _x.E_whv, _x.E_cov, _x.D_cuv, _x.D_riv, _x.D_whv, _x.D_cov, _x.C_cuv, _x.C_riv, _x.C_whv, _x.C_cov, _x.B_cuv, _x.B_riv, _x.B_whv, _x.B_cov, _x.F_cuf, _x.F_cof, _x.F_waf,) = _get_struct_19b().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_19b().pack(_x.E_cuv, _x.E_riv, _x.E_whv, _x.E_cov, _x.D_cuv, _x.D_riv, _x.D_whv, _x.D_cov, _x.C_cuv, _x.C_riv, _x.C_whv, _x.C_cov, _x.B_cuv, _x.B_riv, _x.B_whv, _x.B_cov, _x.F_cuf, _x.F_cof, _x.F_waf))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 19
      (_x.E_cuv, _x.E_riv, _x.E_whv, _x.E_cov, _x.D_cuv, _x.D_riv, _x.D_whv, _x.D_cov, _x.C_cuv, _x.C_riv, _x.C_whv, _x.C_cov, _x.B_cuv, _x.B_riv, _x.B_whv, _x.B_cov, _x.F_cuf, _x.F_cof, _x.F_waf,) = _get_struct_19b().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_19b = None
def _get_struct_19b():
    global _struct_19b
    if _struct_19b is None:
        _struct_19b = struct.Struct("<19b")
    return _struct_19b
